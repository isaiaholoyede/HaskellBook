# Chapter 9: Lists - Notes

## Introduction

This is my notes from **Chapter 9: Lists** of the book [Haskell Programming From First Principles](http://haskellbook.com).

## 9.1 Lists

Lists serve 2 purposes:

1. A way to refer and process a collection of values
2. An infinite series of values, usually generated by a function, which allows them to act as a stream datatype.

## 9.2 The list datatype

The list datatype is defined as:

```Haskell
data [] = [] | a : [a]
```

## 9.3 Pattern matching on Lists

We can use `Maybe` datatype to make a failure case explicit.

```Haskell
data Maybe a = Nothing | Just a
```

## 9.4 List's syntactic sugar

```Haskell
Prelude > (1 : 2 : 3 : []) ++ 4 : []
[1,2,3,4]
```

`[1,2,3]` is the syntactic sugar for (1 : 2 : 3 : [])

## 9.5 Using ranges to construct lists

```Haskell
Prelude > [1..10]
[1,2,3,4,5,6,7,8,9,10]
```

The types of the functions underlying the range syntax are:

```Haskell
enumFrom :: Enum a => a -> [a]
enumFromThen ::Enum a=>a->a->[a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
```

## 9.6 Extracting portions of lists

To extract portions of lists, we can use:

```Haskell
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
```

## 9.7 List comprehensions

List comprehensions are used to generate a new list from a list or lists. For list comprehensions that have multiple generators, the rightmost generator will be exhausted first, then the second rightmost, and so on.

## 9.8 Spines and nonstrict evaluation

The spine is the connective structure that ties the collection (lists, sequences, trees) of values together.

```
1 : 2 : 3 : []
or
1 : (2 : (3 : []))
```

The spine is the recursive series of `cons` constructors signified by (:) as shown below.

```
        : <----------|
      /   \          |
    1      : <-------|
          /  \       | This is the "spine"
        2      : <---|
              / \
             3   []
```

The `cons` cells contain the values. Because the `cons` cell contain the values and the way nonstrict evaluation works, you can evaluate cons cells independently of what they contain. It is possible to evaluate just the spine of the list without evaluating individual values. Evaluation of the list in this representation proceeds *down* the spine. Constructing the list when that is necessary proceeds *up* the spine.

Use `:sprint` in GHCi to print variables and see what have been evaluated already, with the underscore representing expressions that have not been evaluated yet. Because of some behavioral quirks, you have to assign a more concrete type such as `Int` or `Double` when using `:sprint`, otherwise it stays unevaluated `_` in `:sprint`'s output.

The `length` function is only strict in the spine - it only forces evaluation of the spine of a list, not the values. Spines are evaluated independently of values. Values in Haskell get reduced to weak head normal form by default.

## Weak Head Normal Form (WHNF) vs Normal Form (NF)

An expression in NF is fully evaluated and no sub-expression could be evaluated any further.

Expressions in NF are shown below:

```haskell
42
(2, "hello")
\x -> (x + 1)
```

Expressions not in NF are shown below:

```haskell
1 + 2 -- could evaluate to 2
(\x -> x + 1) 2 -- could apply function to argument 2
(1 + 1, 2 + 2) -- could evaluate to (2, 4)
"he" ++ "llo" --- could apply (++)
    ```  
By 'normal form', we mean expression is fully evaluated.

An expression in WHNF:
- has been evaluated to the outermost data constructor or lambda abstraction (the head)
- sub-expression may or may not have been evaluated
- Therefore, every NF expression is also in WHNF, though not every WHNF is in NF.
- To determine whether an expression is in WHNF, we only have to look at the outermost part of the expression.
    - If the outermost part of the expression is a data constructor or a lambda, it is in WHNF.
    - If it is a function application, it is not in WHNF.

Expressions in WHNF are shown below:

```haskell
(1 + 1, 2 + 2) -- the outermost part is the tuple data constructor (,).
-- Recall that (1 + 1, 2 + 2) could have been written as
-- (,) (1 + 1) (2 + 2)
\x -> 2 + 2 -- the outermost part is a lambda abstraction.
'h' : ("e" ++ "llo") -- the outermost part is the cons data constructor (:)
-- Could have been written as
-- (:) 'h' ("e" ++ "llo")
```

Expressions not in WHNF are shown below:

```haskell
1 + 2 -- the outermost part here is an application of function (+)
(\x -> x + 1) 2 -- the outermost part here is an application of (\x -> x + 1) to argument 2
"he" ++ "llo" -- the outermost part is the application of (++)
```

'Weak Head Normal Form' means the expression is only evaluated as far as is necessary to reach a data constructor. An expression is in WHNF, if it is either:

1. a constructor (eventually applied to arguments) e.g. `True`, `Just (square 42)` or `(:) 1`
2. a built-in function applied to too few arguments (perhaps none) e.g. `(+) 2` or `sqrt`.
3. a lambda abstraction e.g. `\x -> expression`

Functions that are spine strict can force complete evaluation of the spine of the list even if they don't force evaluation of each value. Pattern matching is strict by default, so pattern matching on cons cells can mean forcing spine strictness if your function does not stop recursing the list. `length` is strict in the spine but not the values.

## 9.9 Transforming lists of values

We can use `map` or `fmap` to apply a function to each member of a list. `map` can only be used with `[]`. `fmap` is defined in a typeclass named `Functor` can be applied to data other than lists. A common mantra for performance sensitive code in Haskell is "lazy in the spine, strict in the leaves."


## 9.10 Filtering lists of values

Filtering takes a function that returns a `Bool` value, maps that function over a list, and returns a new list of all the values that met the condition.

## 9.11 Zipping lists

Zipping lists together is a means of combining values from multiple lists into a single list. Related functions like `zipWith` allow you to use a combining function to produce a list of results from two lists. `zip` stops as soon as one of the lists runs out of values.

## 9.13 Definitions

In type theory, a *Product Type* is a type made of a set of types compounded over each other. In Haskell, we use tuples or data constructors with more than one argument to represent products. 

In type theory, a *Sum type* of two types is a type whose terms are terms in either type, but not simultaneously. In Haskell, we use `|` pipe to represent sum in a datatype definition.

*Cons* is used as a verb to signify that a list value has been created by *cons'ing* a value onto the head of another list value. In Haskell, `(:)` is the cons operator for the list type. *Cons cell* is a data constructor and a product of the types `a` and `[a]` as defined in the list datatype.

```haskell
data [] a = [] | a : [a]
```

These are the individual cons cells for `[1, 2, 3]`:

* `1 : (2 : (3 : []))`
* `2 : (3 : [])`
* `3 : []`

Generally, for list `xs`, the cons cell is `(x:xs)`, that is, the head `x` points to the first element of the list, the tail `xs` points to the rest of the list.

The *spine* is a way to refer to the structure that glues a collection of values together. In the list datatype, it is formed by the recursive nesting of cons cells.

## References

1. [Haskell Programming from First Principles](http://haskellbook.com/)
2. [What is a Weak Head Normal Form?](http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form)
3. [Weak Head Normal Form](https://wiki.haskell.org/Weak_head_normal_form)
